/**
 * Load Certificate-to-Proposal Mappings into Database
 * 
 * Reads the certificate-proposal-mappings.csv file generated by the proposal builder
 * and loads it into the stg_policy_proposal_mappings table for use by Transform 09.
 * 
 * Usage:
 *   npx tsx scripts/load-certificate-mappings.ts
 *   npx tsx scripts/load-certificate-mappings.ts --file custom-mappings.csv
 *   npx tsx scripts/load-certificate-mappings.ts --schema etl
 */

import * as sql from 'mssql';
import * as fs from 'fs';
import * as readline from 'readline';

interface DatabaseConfig {
  server: string;
  database: string;
  user: string;
  password: string;
  options?: {
    encrypt?: boolean;
    trustServerCertificate?: boolean;
  };
}

interface LoadOptions {
  filePath: string;
  schema: string;
  batchSize: number;
}

async function loadCertificateMappings(
  config: DatabaseConfig,
  options: LoadOptions
): Promise<void> {
  console.log('='.repeat(70));
  console.log('LOAD CERTIFICATE-TO-PROPOSAL MAPPINGS');
  console.log('='.repeat(70));
  console.log('');
  console.log(`File: ${options.filePath}`);
  console.log(`Schema: ${options.schema}`);
  console.log(`Batch Size: ${options.batchSize}`);
  console.log('');

  // Check if file exists
  if (!fs.existsSync(options.filePath)) {
    throw new Error(`File not found: ${options.filePath}`);
  }

  const pool = await sql.connect(config);

  try {
    // Step 1: Create/recreate table
    console.log('Step 1: Creating stg_policy_proposal_mappings table...');
    await pool.request().query(`
      DROP TABLE IF EXISTS [${options.schema}].[stg_policy_proposal_mappings];
      
      CREATE TABLE [${options.schema}].[stg_policy_proposal_mappings] (
          ProposalId NVARCHAR(100) NOT NULL,
          CertificateId NVARCHAR(50) NOT NULL,
          PRIMARY KEY (CertificateId)
      );
    `);
    console.log('  ✓ Table created');
    console.log('');

    // Step 2: Read and load CSV file
    console.log('Step 2: Loading CSV file...');
    
    const fileStream = fs.createReadStream(options.filePath);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    let batch: Array<{ proposalId: string; certificateId: string }> = [];
    let totalRows = 0;
    let batchCount = 0;

    const insertBatch = async (records: Array<{ proposalId: string; certificateId: string }>) => {
      if (records.length === 0) return;
      
      // Build multi-row INSERT statement
      const values = records
        .map(r => `('${r.proposalId.replace(/'/g, "''")}', '${r.certificateId.replace(/'/g, "''")}')`)
        .join(',\n    ');
      
      const query = `
        INSERT INTO [${options.schema}].[stg_policy_proposal_mappings] 
        (ProposalId, CertificateId)
        VALUES
        ${values}
      `;
      
      await pool.request().query(query);
      batchCount++;
      
      if (batchCount % 10 === 0) {
        console.log(`  Progress: ${totalRows.toLocaleString()} rows loaded (${batchCount} batches)`);
      }
    };

    for await (const line of rl) {
      if (!line.trim()) continue;  // Skip empty lines
      
      const [proposalId, certificateId] = line.split(',').map(s => s.trim());
      
      if (!proposalId || !certificateId) {
        console.warn(`  ⚠️ Skipping invalid line: ${line}`);
        continue;
      }
      
      batch.push({ proposalId, certificateId });
      totalRows++;
      
      // Insert batch when it reaches batch size
      if (batch.length >= options.batchSize) {
        await insertBatch(batch);
        batch = [];
      }
    }
    
    // Insert remaining records
    if (batch.length > 0) {
      await insertBatch(batch);
    }
    
    console.log(`  ✓ Total rows loaded: ${totalRows.toLocaleString()} (${batchCount} batches)`);
    console.log('');

    // Step 3: Validate mappings
    console.log('Step 3: Validating mappings...');
    
    const stats = await pool.request().query(`
      SELECT 
        COUNT(*) AS TotalMappings,
        COUNT(DISTINCT ProposalId) AS UniqueProposals,
        COUNT(DISTINCT CertificateId) AS UniqueCertificates
      FROM [${options.schema}].[stg_policy_proposal_mappings]
    `);
    
    const { TotalMappings, UniqueProposals, UniqueCertificates } = stats.recordset[0];
    
    console.log(`  Total mappings: ${TotalMappings.toLocaleString()}`);
    console.log(`  Unique proposals: ${UniqueProposals.toLocaleString()}`);
    console.log(`  Unique certificates: ${UniqueCertificates.toLocaleString()}`);
    
    // Check for invalid certificate IDs
    const invalidCheck = await pool.request().query(`
      SELECT COUNT(*) AS InvalidCount
      FROM [${options.schema}].[stg_policy_proposal_mappings] m
      WHERE NOT EXISTS (
        SELECT 1 
        FROM [${options.schema}].[input_certificate_info] ci
        WHERE CAST(ci.CertificateId AS NVARCHAR(50)) = m.CertificateId
      )
    `);
    
    const invalidCount = invalidCheck.recordset[0].InvalidCount;
    
    if (invalidCount > 0) {
      console.log(`  ⚠️ Warning: ${invalidCount} certificates in mapping not found in input data`);
    } else {
      console.log('  ✓ All certificate IDs are valid');
    }
    
    console.log('');
    console.log('='.repeat(70));
    console.log('LOAD COMPLETE');
    console.log('='.repeat(70));
    
  } finally {
    await pool.close();
  }
}

// =============================================================================
// Main Execution
// =============================================================================

if (require.main === module) {
  const args = process.argv.slice(2);
  
  // Parse CLI arguments
  const options: LoadOptions = {
    filePath: args.includes('--file')
      ? args[args.indexOf('--file') + 1]
      : 'certificate-proposal-mappings.csv',
    schema: args.includes('--schema')
      ? args[args.indexOf('--schema') + 1]
      : 'etl',
    batchSize: args.includes('--batch-size')
      ? parseInt(args[args.indexOf('--batch-size') + 1])
      : 5000
  };
  
  // Get connection string from environment
  const connectionString = process.env.SQLSERVER;
  if (!connectionString) {
    console.error('ERROR: SQLSERVER environment variable not set');
    console.error('Format: Server=host;Database=db;User Id=user;Password=pass');
    process.exit(1);
  }

  // Parse connection string
  const parts = connectionString.split(';').reduce((acc, part) => {
    const [key, value] = part.split('=');
    if (key && value) acc[key.trim().toLowerCase()] = value.trim();
    return acc;
  }, {} as Record<string, string>);

  const config: DatabaseConfig = {
    server: parts['server'] || parts['data source'] || '',
    database: parts['database'] || parts['initial catalog'] || '',
    user: parts['user id'] || parts['uid'] || '',
    password: parts['password'] || parts['pwd'] || '',
    options: {
      encrypt: true,
      trustServerCertificate: true
    }
  };

  loadCertificateMappings(config, options)
    .then(() => {
      console.log('✅ Success!');
      process.exit(0);
    })
    .catch(err => {
      console.error('❌ Error:', err.message);
      console.error(err.stack);
      process.exit(1);
    });
}
